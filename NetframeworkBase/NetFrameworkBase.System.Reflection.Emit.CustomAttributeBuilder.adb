--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2019 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-NetFramework                                                        --
--    Version   : 1.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with NetFrameworkBase.System.Object;
with NetFrameworkBase.System.Reflection.ConstructorInfo;
with NetFrameworkBase.System.Reflection.PropertyInfo;
with NetFrameworkBase.System.Reflection.FieldInfo;
with NetFrameworkWin32;              use NetFrameworkWin32;
with NetFrameworkAdaRuntime;         use NetFrameworkAdaRuntime;
with Ada.Unchecked_Conversion;
with Interfaces.C;
--------------------------------------------------------------------------------
package body NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder is
   
   use type Interfaces.C.unsigned_short;
   
   This_AssemblyFile : constant Standard.Wide_String := "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorlib.dll";
   This_AssemblyName : constant Standard.Wide_String := "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
   This_TypeName     : constant Standard.Wide_String := "System.Reflection.Emit.CustomAttributeBuilder";
   TypeInstance      : aliased IType_Ptr := null;
   
   function Instance return IType_Ptr is
   begin
      if TypeInstance = null then
         declare
            Hr          : HRESULT := 0;
            Runtime     : RuntimeHost := Instance;
            Assembly    : IAssembly_Ptr := null;
            TypeName    : NetFrameworkBase.BSTR := To_BSTR(This_TypeName);
         begin
            if IsAssemblyLoaded (RunTime, This_AssemblyName) = false then
               Assembly := LoadAssembly(Runtime, This_AssemblyName);
            else
               Assembly := GetAssembly(Runtime, This_AssemblyName);
            end if;
            Hr := Assembly.GetType_2(TypeName, TypeInstance'access);
            SysFreeString(TypeName);
         end;
      end if;
      return TypeInstance;
   end;
   
   function Constructor
   (
      con : NetFrameworkBase.System.Reflection.ConstructorInfo.Kind_Ptr;
      constructorArgs : NetFrameworkBase.System.Object.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr is
   begin
      return RetVal : NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr := new NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind do
      declare
         function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
         Hr            : HResult := 0;
         p_Parameters  : aliased LPSAFEARRAY := null;
         p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
         p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
         p_Value       : aliased VARIANT;
         p_Value_Ptr   : access VARIANT := p_Value'access;
         p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
         p1_Parameters : aliased LPSAFEARRAY := null;
         p1_Bounds     : aliased SAFEARRAYBOUND := (constructorArgs'Length , 0);
         p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p1_Tmp        : aliased IUnknown_Ptr;
         p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
      begin
         p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
         ------------------------------------------------------------
         p_Index(1) := 0;
         p_Value := GetObject (con.m_Kind);
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 1;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
            for i in constructorArgs'range loop
               p1_Index(1) := Interfaces.C.long(i) - 1;
               p1_Tmp := GetObject (constructorArgs(i).m_Kind);
               Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
            end loop;
            p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         NetFrameworkAdaRuntime.CreateInstance (RetVal.m_Kind, This_AssemblyName, This_TypeName, Instance, NetFrameworkWin32.BindingFlags'(CreateInstance)'Enum_rep, p_Parameters);
         Hr := SafeArrayDestroy (p1_Parameters);
         Hr := SafeArrayDestroy(p_Parameters);
      end;
      end return;
   end;
   
   function Constructor
   (
      con : NetFrameworkBase.System.Reflection.ConstructorInfo.Kind_Ptr;
      constructorArgs : NetFrameworkBase.System.Object.Kind_Array;
      namedProperties : NetFrameworkBase.System.Reflection.PropertyInfo.Kind_Array;
      propertyValues : NetFrameworkBase.System.Object.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr is
   begin
      return RetVal : NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr := new NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind do
      declare
         function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
         Hr            : HResult := 0;
         p_Parameters  : aliased LPSAFEARRAY := null;
         p_Bounds      : aliased SAFEARRAYBOUND := (4 , 0);
         p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
         p_Value       : aliased VARIANT;
         p_Value_Ptr   : access VARIANT := p_Value'access;
         p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
         p1_Parameters : aliased LPSAFEARRAY := null;
         p1_Bounds     : aliased SAFEARRAYBOUND := (constructorArgs'Length , 0);
         p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p1_Tmp        : aliased IUnknown_Ptr;
         p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
         p2_Parameters : aliased LPSAFEARRAY := null;
         p2_Bounds     : aliased SAFEARRAYBOUND := (namedProperties'Length , 0);
         p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p2_Tmp        : aliased IUnknown_Ptr;
         p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
         p3_Parameters : aliased LPSAFEARRAY := null;
         p3_Bounds     : aliased SAFEARRAYBOUND := (propertyValues'Length , 0);
         p3_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p3_Tmp        : aliased IUnknown_Ptr;
         p3_Tmp_Ptr    : access IUnknown_Ptr := p3_Tmp'access;
      begin
         p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
         ------------------------------------------------------------
         p_Index(1) := 0;
         p_Value := GetObject (con.m_Kind);
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 1;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
            for i in constructorArgs'range loop
               p1_Index(1) := Interfaces.C.long(i) - 1;
               p1_Tmp := GetObject (constructorArgs(i).m_Kind);
               Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
            end loop;
            p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 2;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
            for i in namedProperties'range loop
               p2_Index(1) := Interfaces.C.long(i) - 1;
               p2_Tmp := GetObject (namedProperties(i).m_Kind);
               Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
            end loop;
            p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Reflection.PropertyInfo[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 3;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p3_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p3_Bounds'access);
            for i in propertyValues'range loop
               p3_Index(1) := Interfaces.C.long(i) - 1;
               p3_Tmp := GetObject (propertyValues(i).m_Kind);
               Hr := SafeArrayPutElement (p3_Parameters, p3_Index (p3_Index'first)'access, Convert (p3_Tmp));
            end loop;
            p_Value := To_Variant (p3_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         NetFrameworkAdaRuntime.CreateInstance (RetVal.m_Kind, This_AssemblyName, This_TypeName, Instance, NetFrameworkWin32.BindingFlags'(CreateInstance)'Enum_rep, p_Parameters);
         Hr := SafeArrayDestroy (p1_Parameters);
         Hr := SafeArrayDestroy (p2_Parameters);
         Hr := SafeArrayDestroy (p3_Parameters);
         Hr := SafeArrayDestroy(p_Parameters);
      end;
      end return;
   end;
   
   function Constructor
   (
      con : NetFrameworkBase.System.Reflection.ConstructorInfo.Kind_Ptr;
      constructorArgs : NetFrameworkBase.System.Object.Kind_Array;
      namedFields : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array;
      fieldValues : NetFrameworkBase.System.Object.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr is
   begin
      return RetVal : NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr := new NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind do
      declare
         function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
         Hr            : HResult := 0;
         p_Parameters  : aliased LPSAFEARRAY := null;
         p_Bounds      : aliased SAFEARRAYBOUND := (4 , 0);
         p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
         p_Value       : aliased VARIANT;
         p_Value_Ptr   : access VARIANT := p_Value'access;
         p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
         p1_Parameters : aliased LPSAFEARRAY := null;
         p1_Bounds     : aliased SAFEARRAYBOUND := (constructorArgs'Length , 0);
         p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p1_Tmp        : aliased IUnknown_Ptr;
         p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
         p2_Parameters : aliased LPSAFEARRAY := null;
         p2_Bounds     : aliased SAFEARRAYBOUND := (namedFields'Length , 0);
         p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p2_Tmp        : aliased IUnknown_Ptr;
         p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
         p3_Parameters : aliased LPSAFEARRAY := null;
         p3_Bounds     : aliased SAFEARRAYBOUND := (fieldValues'Length , 0);
         p3_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p3_Tmp        : aliased IUnknown_Ptr;
         p3_Tmp_Ptr    : access IUnknown_Ptr := p3_Tmp'access;
      begin
         p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
         ------------------------------------------------------------
         p_Index(1) := 0;
         p_Value := GetObject (con.m_Kind);
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 1;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
            for i in constructorArgs'range loop
               p1_Index(1) := Interfaces.C.long(i) - 1;
               p1_Tmp := GetObject (constructorArgs(i).m_Kind);
               Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
            end loop;
            p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 2;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
            for i in namedFields'range loop
               p2_Index(1) := Interfaces.C.long(i) - 1;
               p2_Tmp := GetObject (namedFields(i).m_Kind);
               Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
            end loop;
            p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Reflection.FieldInfo[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 3;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p3_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p3_Bounds'access);
            for i in fieldValues'range loop
               p3_Index(1) := Interfaces.C.long(i) - 1;
               p3_Tmp := GetObject (fieldValues(i).m_Kind);
               Hr := SafeArrayPutElement (p3_Parameters, p3_Index (p3_Index'first)'access, Convert (p3_Tmp));
            end loop;
            p_Value := To_Variant (p3_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         NetFrameworkAdaRuntime.CreateInstance (RetVal.m_Kind, This_AssemblyName, This_TypeName, Instance, NetFrameworkWin32.BindingFlags'(CreateInstance)'Enum_rep, p_Parameters);
         Hr := SafeArrayDestroy (p1_Parameters);
         Hr := SafeArrayDestroy (p2_Parameters);
         Hr := SafeArrayDestroy (p3_Parameters);
         Hr := SafeArrayDestroy(p_Parameters);
      end;
      end return;
   end;
   
   function Constructor
   (
      con : NetFrameworkBase.System.Reflection.ConstructorInfo.Kind_Ptr;
      constructorArgs : NetFrameworkBase.System.Object.Kind_Array;
      namedProperties : NetFrameworkBase.System.Reflection.PropertyInfo.Kind_Array;
      propertyValues : NetFrameworkBase.System.Object.Kind_Array;
      namedFields : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array;
      fieldValues : NetFrameworkBase.System.Object.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr is
   begin
      return RetVal : NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind_Ptr := new NetFrameworkBase.System.Reflection.Emit.CustomAttributeBuilder.Kind do
      declare
         function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
         Hr            : HResult := 0;
         p_Parameters  : aliased LPSAFEARRAY := null;
         p_Bounds      : aliased SAFEARRAYBOUND := (6 , 0);
         p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
         p_Value       : aliased VARIANT;
         p_Value_Ptr   : access VARIANT := p_Value'access;
         p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
         p1_Parameters : aliased LPSAFEARRAY := null;
         p1_Bounds     : aliased SAFEARRAYBOUND := (constructorArgs'Length , 0);
         p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p1_Tmp        : aliased IUnknown_Ptr;
         p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
         p2_Parameters : aliased LPSAFEARRAY := null;
         p2_Bounds     : aliased SAFEARRAYBOUND := (namedProperties'Length , 0);
         p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p2_Tmp        : aliased IUnknown_Ptr;
         p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
         p3_Parameters : aliased LPSAFEARRAY := null;
         p3_Bounds     : aliased SAFEARRAYBOUND := (propertyValues'Length , 0);
         p3_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p3_Tmp        : aliased IUnknown_Ptr;
         p3_Tmp_Ptr    : access IUnknown_Ptr := p3_Tmp'access;
         p4_Parameters : aliased LPSAFEARRAY := null;
         p4_Bounds     : aliased SAFEARRAYBOUND := (namedFields'Length , 0);
         p4_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p4_Tmp        : aliased IUnknown_Ptr;
         p4_Tmp_Ptr    : access IUnknown_Ptr := p4_Tmp'access;
         p5_Parameters : aliased LPSAFEARRAY := null;
         p5_Bounds     : aliased SAFEARRAYBOUND := (fieldValues'Length , 0);
         p5_Index      : aliased array(1..1) of aliased LONG := (others => 0);
         p5_Tmp        : aliased IUnknown_Ptr;
         p5_Tmp_Ptr    : access IUnknown_Ptr := p5_Tmp'access;
      begin
         p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
         ------------------------------------------------------------
         p_Index(1) := 0;
         p_Value := GetObject (con.m_Kind);
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 1;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
            for i in constructorArgs'range loop
               p1_Index(1) := Interfaces.C.long(i) - 1;
               p1_Tmp := GetObject (constructorArgs(i).m_Kind);
               Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
            end loop;
            p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 2;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
            for i in namedProperties'range loop
               p2_Index(1) := Interfaces.C.long(i) - 1;
               p2_Tmp := GetObject (namedProperties(i).m_Kind);
               Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
            end loop;
            p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Reflection.PropertyInfo[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 3;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p3_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p3_Bounds'access);
            for i in propertyValues'range loop
               p3_Index(1) := Interfaces.C.long(i) - 1;
               p3_Tmp := GetObject (propertyValues(i).m_Kind);
               Hr := SafeArrayPutElement (p3_Parameters, p3_Index (p3_Index'first)'access, Convert (p3_Tmp));
            end loop;
            p_Value := To_Variant (p3_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 4;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p4_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p4_Bounds'access);
            for i in namedFields'range loop
               p4_Index(1) := Interfaces.C.long(i) - 1;
               p4_Tmp := GetObject (namedFields(i).m_Kind);
               Hr := SafeArrayPutElement (p4_Parameters, p4_Index (p4_Index'first)'access, Convert (p4_Tmp));
            end loop;
            p_Value := To_Variant (p4_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Reflection.FieldInfo[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         ------------------------------------------------------------
         p_Index(1) := 5;
         declare
            use Interfaces.C;
            function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
         begin
            p5_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p5_Bounds'access);
            for i in fieldValues'range loop
               p5_Index(1) := Interfaces.C.long(i) - 1;
               p5_Tmp := GetObject (fieldValues(i).m_Kind);
               Hr := SafeArrayPutElement (p5_Parameters, p5_Index (p5_Index'first)'access, Convert (p5_Tmp));
            end loop;
            p_Value := To_Variant (p5_Parameters, VT_UNKNOWN);
         end;
         -- fixme parameter type := [array] System.Object[]
      
         Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
         NetFrameworkAdaRuntime.CreateInstance (RetVal.m_Kind, This_AssemblyName, This_TypeName, Instance, NetFrameworkWin32.BindingFlags'(CreateInstance)'Enum_rep, p_Parameters);
         Hr := SafeArrayDestroy (p1_Parameters);
         Hr := SafeArrayDestroy (p2_Parameters);
         Hr := SafeArrayDestroy (p3_Parameters);
         Hr := SafeArrayDestroy (p4_Parameters);
         Hr := SafeArrayDestroy (p5_Parameters);
         Hr := SafeArrayDestroy(p_Parameters);
      end;
      end return;
   end;
   
end;
