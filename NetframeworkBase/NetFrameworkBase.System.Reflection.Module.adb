--------------------------------------------------------------------------------
-- <auto-generated>                                                           --
--     This code was generated by a tool.                                     --
--                                                                            --
--     Changes to this file may cause incorrect behavior and will be lost if  --
--     the code is regenerated.                                               --
-- </auto-generated>                                                          --
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--                                                                            --
--    Copyright(c) 2019 Alexander Gamper, All Rights Reserved.                --
--                                                                            --
--    Ada-NetFramework                                                        --
--    Version   : 1.0.0.0                                                     --
--                                                                            --
-- This program is free software: you can redistribute it and / or modify     --
-- it under the terms of the GNU Lesser General Public License as published by--
-- the Free Software Foundation, either version 3 of the License, or          --
-- (at your option) any later version.                                        --
--                                                                            --
-- This program is distributed in the hope that it will be useful,            --
-- but WITHOUT ANY WARRANTY; without even the implied warranty of             --
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the               --
-- GNU Lesser General Public License for more details.                        --
--                                                                            --
-- You should have received a copy of the GNU Lesser General Public License   --
-- along with this program.If not, see http://www.gnu.org/licenses            --
--                                                                            --
--------------------------------------------------------------------------------
with NetFrameworkBase.System.Object;
with NetFrameworkBase.System.Type_x;
with NetFrameworkBase.System.Reflection.PortableExecutableKinds;
with NetFrameworkBase.System.Reflection.ImageFileMachine;
with NetFrameworkBase.System.Runtime.Serialization.SerializationInfo;
with NetFrameworkBase.System.Runtime.Serialization.StreamingContext;
with NetFrameworkBase.System.Reflection.TypeFilter;
with NetFrameworkBase.System.Reflection.BindingFlags;
with NetFrameworkBase.System.Reflection.Binder;
with NetFrameworkBase.System.Reflection.CallingConventions;
with NetFrameworkBase.System.Reflection.ParameterModifier;
with NetFrameworkBase.System.Reflection.MethodBase;
with NetFrameworkBase.System.Reflection.FieldInfo;
with NetFrameworkBase.System.Reflection.MemberInfo;
with NetFrameworkBase.System.Guid;
with NetFrameworkBase.System.Reflection.MethodInfo;
with NetFrameworkBase.System.Reflection.Assembly;
with NetFrameworkBase.System.ModuleHandle;
with NetFrameworkBase.System.Security.Cryptography.X509Certificates.X509Certificate;
with NetFrameworkWin32;              use NetFrameworkWin32;
with NetFrameworkAdaRuntime;         use NetFrameworkAdaRuntime;
with Ada.Unchecked_Conversion;
with Interfaces.C;
--------------------------------------------------------------------------------
package body NetFrameworkBase.System.Reflection.Module is
   
   use type Interfaces.C.unsigned_short;
   
   This_AssemblyFile : constant Standard.Wide_String := "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\mscorlib.dll";
   This_AssemblyName : constant Standard.Wide_String := "mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089";
   This_TypeName     : constant Standard.Wide_String := "System.Reflection.Module";
   TypeInstance      : aliased IType_Ptr := null;
   
   function Instance return IType_Ptr is
   begin
      if TypeInstance = null then
         declare
            Hr          : HRESULT := 0;
            Runtime     : RuntimeHost := Instance;
            Assembly    : IAssembly_Ptr := null;
            TypeName    : NetFrameworkBase.BSTR := To_BSTR(This_TypeName);
         begin
            if IsAssemblyLoaded (RunTime, This_AssemblyName) = false then
               Assembly := LoadAssembly(Runtime, This_AssemblyName);
            else
               Assembly := GetAssembly(Runtime, This_AssemblyName);
            end if;
            Hr := Assembly.GetType_2(TypeName, TypeInstance'access);
            SysFreeString(TypeName);
         end;
      end if;
      return TypeInstance;
   end;
   
   function op_Equality
   (
      left : NetFrameworkBase.System.Reflection.Module.Kind_Ptr;
      right : NetFrameworkBase.System.Reflection.Module.Kind_Ptr
   )
   return NetFrameworkBase.Boolean is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("op_Equality");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Boolean;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Static)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (left.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := GetObject (right.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      VariantInit(p_Target'access);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function op_Inequality
   (
      left : NetFrameworkBase.System.Reflection.Module.Kind_Ptr;
      right : NetFrameworkBase.System.Reflection.Module.Kind_Ptr
   )
   return NetFrameworkBase.Boolean is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("op_Inequality");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Boolean;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Static)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (left.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := GetObject (right.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      VariantInit(p_Target'access);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function Equals
   (
      this : in out Module.Kind;
      o : NetFrameworkBase.System.Object.Kind_Ptr
   )
   return NetFrameworkBase.Boolean is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("Equals");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Boolean;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (o.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function GetHashCode
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.Int32 is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetHashCode");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Int32;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function ToString
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.BSTR is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ToString");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.BSTR;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function GetCustomAttributes
   (
      this : in out Module.Kind;
      inherit : NetFrameworkBase.Boolean
   )
   return NetFrameworkBase.System.Object.Kind_Array is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetCustomAttributes");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Object.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Object.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Object.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Object.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(inherit);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function GetCustomAttributes
   (
      this : in out Module.Kind;
      attributeType : NetFrameworkBase.System.Type_x.Kind_Ptr;
      inherit : NetFrameworkBase.Boolean
   )
   return NetFrameworkBase.System.Object.Kind_Array is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetCustomAttributes");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Object.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Object.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Object.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Object.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (attributeType.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := To_Variant(inherit);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function IsDefined
   (
      this : in out Module.Kind;
      attributeType : NetFrameworkBase.System.Type_x.Kind_Ptr;
      inherit : NetFrameworkBase.Boolean
   )
   return NetFrameworkBase.Boolean is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("IsDefined");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Boolean;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (attributeType.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := To_Variant(inherit);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function ResolveMethod
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32
   )
   return NetFrameworkBase.System.Reflection.MethodBase.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveMethod");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Reflection.MethodBase.Kind_Ptr := new NetFrameworkBase.System.Reflection.MethodBase.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveMethod
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32;
      genericTypeArguments : NetFrameworkBase.System.Type_x.Kind_Array;
      genericMethodArguments : NetFrameworkBase.System.Type_x.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.MethodBase.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (3 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveMethod");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p1_Parameters : aliased LPSAFEARRAY := null;
      p1_Bounds     : aliased SAFEARRAYBOUND := (genericTypeArguments'Length , 0);
      p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p1_Tmp        : aliased IUnknown_Ptr;
      p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
      p2_Parameters : aliased LPSAFEARRAY := null;
      p2_Bounds     : aliased SAFEARRAYBOUND := (genericMethodArguments'Length , 0);
      p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p2_Tmp        : aliased IUnknown_Ptr;
      p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
      RetVal        : NetFrameworkBase.System.Reflection.MethodBase.Kind_Ptr := new NetFrameworkBase.System.Reflection.MethodBase.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
         for i in genericTypeArguments'range loop
            p1_Index(1) := Interfaces.C.long(i) - 1;
            p1_Tmp := GetObject (genericTypeArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
         end loop;
         p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 2;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
         for i in genericMethodArguments'range loop
            p2_Index(1) := Interfaces.C.long(i) - 1;
            p2_Tmp := GetObject (genericMethodArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
         end loop;
         p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p1_Parameters);
      Hr := SafeArrayDestroy (p2_Parameters);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveField
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32
   )
   return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveField");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.FieldInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveField
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32;
      genericTypeArguments : NetFrameworkBase.System.Type_x.Kind_Array;
      genericMethodArguments : NetFrameworkBase.System.Type_x.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (3 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveField");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p1_Parameters : aliased LPSAFEARRAY := null;
      p1_Bounds     : aliased SAFEARRAYBOUND := (genericTypeArguments'Length , 0);
      p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p1_Tmp        : aliased IUnknown_Ptr;
      p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
      p2_Parameters : aliased LPSAFEARRAY := null;
      p2_Bounds     : aliased SAFEARRAYBOUND := (genericMethodArguments'Length , 0);
      p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p2_Tmp        : aliased IUnknown_Ptr;
      p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
      RetVal        : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.FieldInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
         for i in genericTypeArguments'range loop
            p1_Index(1) := Interfaces.C.long(i) - 1;
            p1_Tmp := GetObject (genericTypeArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
         end loop;
         p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 2;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
         for i in genericMethodArguments'range loop
            p2_Index(1) := Interfaces.C.long(i) - 1;
            p2_Tmp := GetObject (genericMethodArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
         end loop;
         p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p1_Parameters);
      Hr := SafeArrayDestroy (p2_Parameters);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveType
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32
   )
   return NetFrameworkBase.System.Type_x.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveType");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Type_x.Kind_Ptr := new NetFrameworkBase.System.Type_x.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveType
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32;
      genericTypeArguments : NetFrameworkBase.System.Type_x.Kind_Array;
      genericMethodArguments : NetFrameworkBase.System.Type_x.Kind_Array
   )
   return NetFrameworkBase.System.Type_x.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (3 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveType");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p1_Parameters : aliased LPSAFEARRAY := null;
      p1_Bounds     : aliased SAFEARRAYBOUND := (genericTypeArguments'Length , 0);
      p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p1_Tmp        : aliased IUnknown_Ptr;
      p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
      p2_Parameters : aliased LPSAFEARRAY := null;
      p2_Bounds     : aliased SAFEARRAYBOUND := (genericMethodArguments'Length , 0);
      p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p2_Tmp        : aliased IUnknown_Ptr;
      p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
      RetVal        : NetFrameworkBase.System.Type_x.Kind_Ptr := new NetFrameworkBase.System.Type_x.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
         for i in genericTypeArguments'range loop
            p1_Index(1) := Interfaces.C.long(i) - 1;
            p1_Tmp := GetObject (genericTypeArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
         end loop;
         p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 2;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
         for i in genericMethodArguments'range loop
            p2_Index(1) := Interfaces.C.long(i) - 1;
            p2_Tmp := GetObject (genericMethodArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
         end loop;
         p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p1_Parameters);
      Hr := SafeArrayDestroy (p2_Parameters);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveMember
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32
   )
   return NetFrameworkBase.System.Reflection.MemberInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveMember");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Reflection.MemberInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.MemberInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveMember
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32;
      genericTypeArguments : NetFrameworkBase.System.Type_x.Kind_Array;
      genericMethodArguments : NetFrameworkBase.System.Type_x.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.MemberInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (3 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveMember");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p1_Parameters : aliased LPSAFEARRAY := null;
      p1_Bounds     : aliased SAFEARRAYBOUND := (genericTypeArguments'Length , 0);
      p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p1_Tmp        : aliased IUnknown_Ptr;
      p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
      p2_Parameters : aliased LPSAFEARRAY := null;
      p2_Bounds     : aliased SAFEARRAYBOUND := (genericMethodArguments'Length , 0);
      p2_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p2_Tmp        : aliased IUnknown_Ptr;
      p2_Tmp_Ptr    : access IUnknown_Ptr := p2_Tmp'access;
      RetVal        : NetFrameworkBase.System.Reflection.MemberInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.MemberInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
         for i in genericTypeArguments'range loop
            p1_Index(1) := Interfaces.C.long(i) - 1;
            p1_Tmp := GetObject (genericTypeArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
         end loop;
         p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 2;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p2_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p2_Bounds'access);
         for i in genericMethodArguments'range loop
            p2_Index(1) := Interfaces.C.long(i) - 1;
            p2_Tmp := GetObject (genericMethodArguments(i).m_Kind);
            Hr := SafeArrayPutElement (p2_Parameters, p2_Index (p2_Index'first)'access, Convert (p2_Tmp));
         end loop;
         p_Value := To_Variant (p2_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p1_Parameters);
      Hr := SafeArrayDestroy (p2_Parameters);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ResolveSignature
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32
   )
   return NetFrameworkBase.Byte_Array is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveSignature");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.Byte_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.Byte_Array(1..integer(Index));
            Value  : aliased NetFrameworkBase.Byte;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Value'Address));
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function ResolveString
   (
      this : in out Module.Kind;
      metadataToken : NetFrameworkBase.Int32
   )
   return NetFrameworkBase.BSTR is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ResolveString");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.BSTR;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(metadataToken);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   procedure GetPEKind
   (
      this : in out Module.Kind;
      peKind : out NetFrameworkBase.System.Reflection.PortableExecutableKinds.Kind;
      machine : out NetFrameworkBase.System.Reflection.ImageFileMachine.Kind
   ) is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      function Convert is new Ada.Unchecked_Conversion (LONG, NetFrameworkBase.System.Reflection.PortableExecutableKinds.Kind);
      function Convert is new Ada.Unchecked_Conversion (LONG, NetFrameworkBase.System.Reflection.ImageFileMachine.Kind);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetPEKind");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p_peKindEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.PortableExecutableKinds.Instance;
      p_peKindEnum : aliased VARIANT := To_Variant (CreateEnum (p_peKindEnumType, peKind'Enum_rep));
      p_machineEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.ImageFileMachine.Instance;
      p_machineEnum : aliased VARIANT := To_Variant (CreateEnum (p_machineEnumType, machine'Enum_rep));
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      VariantInit (p_Value'access);
      p_Value.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
      -- parameter type := [out] System.Reflection.PortableExecutableKinds&
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      VariantInit (p_Value'access);
      p_Value.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
      -- parameter type := [out] System.Reflection.ImageFileMachine&
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      -- set out parameter [peKind : System.Reflection.PortableExecutableKinds]
      p_Index(1) := 0;
      Hr := SafeArrayGetElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      peKind := Convert (p_Value.field_1.field_1.field_1.lval);
      -- set out parameter [machine : System.Reflection.ImageFileMachine]
      p_Index(1) := 1;
      Hr := SafeArrayGetElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      machine := Convert (p_Value.field_1.field_1.field_1.lval);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
   end;
   
   function MDStreamVersion
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.Int32 is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("MDStreamVersion");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Int32;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   procedure GetObjectData
   (
      this : in out Module.Kind;
      info : NetFrameworkBase.System.Runtime.Serialization.SerializationInfo.Kind_Ptr;
      context : NetFrameworkBase.System.Runtime.Serialization.StreamingContext.Kind_Ptr
   ) is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetObjectData");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (info.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := GetObject (context.m_Kind); -- Parameter Type = ValueType
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
   end;
   
   function GetType
   (
      this : in out Module.Kind;
      className : NetFrameworkBase.BSTR;
      ignoreCase : NetFrameworkBase.Boolean
   )
   return NetFrameworkBase.System.Type_x.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetType");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Type_x.Kind_Ptr := new NetFrameworkBase.System.Type_x.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(className);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := To_Variant(ignoreCase);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetType
   (
      this : in out Module.Kind;
      className : NetFrameworkBase.BSTR
   )
   return NetFrameworkBase.System.Type_x.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetType");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Type_x.Kind_Ptr := new NetFrameworkBase.System.Type_x.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(className);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetType
   (
      this : in out Module.Kind;
      className : NetFrameworkBase.BSTR;
      throwOnError : NetFrameworkBase.Boolean;
      ignoreCase : NetFrameworkBase.Boolean
   )
   return NetFrameworkBase.System.Type_x.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (3 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetType");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Type_x.Kind_Ptr := new NetFrameworkBase.System.Type_x.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(className);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := To_Variant(throwOnError);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 2;
      p_Value := To_Variant(ignoreCase);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function FullyQualifiedName
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.BSTR is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("FullyQualifiedName");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.BSTR;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function FindTypes
   (
      this : in out Module.Kind;
      filter : NetFrameworkBase.System.Reflection.TypeFilter.Kind_Ptr;
      filterCriteria : NetFrameworkBase.System.Object.Kind_Ptr
   )
   return NetFrameworkBase.System.Type_x.Kind_Array is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("FindTypes");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Type_x.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Type_x.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Type_x.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Type_x.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := GetObject (filter.m_Kind); -- Parameter Type = Delegate
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := GetObject (filterCriteria.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function GetTypes
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.Type_x.Kind_Array is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetTypes");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Type_x.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Type_x.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Type_x.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Type_x.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function ModuleVersionId
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.Guid.Kind_Ptr is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ModuleVersionId");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Guid.Kind_Ptr := new NetFrameworkBase.System.Guid.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function MetadataToken
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.Int32 is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("MetadataToken");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Int32;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function IsResource
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.Boolean is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("IsResource");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.Boolean;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function GetFields
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetFields");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Reflection.FieldInfo.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function GetFields
   (
      this : in out Module.Kind;
      bindingFlags : NetFrameworkBase.System.Reflection.BindingFlags.Kind
   )
   return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetFields");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p_bindingFlagsEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.BindingFlags.Instance;
      p_bindingFlagsEnum : aliased VARIANT := To_Variant (CreateEnum (p_bindingFlagsEnumType, bindingFlags'Enum_rep));
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Reflection.FieldInfo.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := p_bindingFlagsEnum;
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function GetField
   (
      this : in out Module.Kind;
      name : NetFrameworkBase.BSTR
   )
   return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetField");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.FieldInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(name);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetField
   (
      this : in out Module.Kind;
      name : NetFrameworkBase.BSTR;
      bindingAttr : NetFrameworkBase.System.Reflection.BindingFlags.Kind
   )
   return NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetField");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p_bindingAttrEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.BindingFlags.Instance;
      p_bindingAttrEnum : aliased VARIANT := To_Variant (CreateEnum (p_bindingAttrEnumType, bindingAttr'Enum_rep));
      RetVal        : NetFrameworkBase.System.Reflection.FieldInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.FieldInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(name);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := p_bindingAttrEnum;
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetMethods
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Array is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetMethods");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Reflection.MethodInfo.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function GetMethods
   (
      this : in out Module.Kind;
      bindingFlags : NetFrameworkBase.System.Reflection.BindingFlags.Kind
   )
   return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Array is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetMethods");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p_bindingFlagsEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.BindingFlags.Instance;
      p_bindingFlagsEnum : aliased VARIANT := To_Variant (CreateEnum (p_bindingFlagsEnumType, bindingFlags'Enum_rep));
   
      function GetArray (sa : access NetFrameworkWin32.SAFEARRAY) return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Array is
         Hr     : NetFrameworkWin32.HRESULT := 0;
         LBound : aliased NetFrameworkWin32.LONG := 0;
         UBound : aliased NetFrameworkWin32.LONG := 0;
         Index  : aliased NetFrameworkWin32.LONG := 0;
         use type Interfaces.C.long;
      begin
         Hr := SafeArrayGetLBound (sa, 1, LBound'access);
         Hr := SafeArrayGetUBound (sa, 1, UBound'access);
         Index := UBound - LBound + 1;
         declare
            RetVal : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Array(1..integer(Index));
            Value  : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr;
            Var    : aliased VARIANT;
            Item   : PVOID;
            function Convert is new Ada.Unchecked_Conversion (NetFrameworkWin32.Address, PVOID);
            function Convert is new Ada.Unchecked_Conversion (VOID, PVOID);
         begin
            Index := 0;
            for I in RetVal'range loop
               Hr := SafeArrayGetElement (sa, Index'unchecked_access, Convert (Item'Address));
               VariantInit (Var'access);
               Var.field_1.field_1.vt := VT_UNKNOWN'Enum_rep;
               Var.field_1.field_1.field_1.byref := Item;
               Value := new NetFrameworkBase.System.Reflection.MethodInfo.Kind;
               SetObject (Value.m_Kind, Var);
               RetVal(integer(I)) := Value;
               Index := Index + 1;
            end loop;
            Hr := SafeArrayDestroy (sa);
            return RetVal;
         end;
      end;
   
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := p_bindingFlagsEnum;
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return GetArray (p_RetVal.field_1.field_1.field_1.parray);
   end;
   
   function GetMethod
   (
      this : in out Module.Kind;
      name : NetFrameworkBase.BSTR;
      bindingAttr : NetFrameworkBase.System.Reflection.BindingFlags.Kind;
      binder : NetFrameworkBase.System.Reflection.Binder.Kind_Ptr;
      callConvention : NetFrameworkBase.System.Reflection.CallingConventions.Kind;
      types : NetFrameworkBase.System.Type_x.Kind_Array;
      modifiers : NetFrameworkBase.System.Reflection.ParameterModifier.Kind_Array_Ptr
   )
   return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (6 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetMethod");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p_bindingAttrEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.BindingFlags.Instance;
      p_bindingAttrEnum : aliased VARIANT := To_Variant (CreateEnum (p_bindingAttrEnumType, bindingAttr'Enum_rep));
      p_callConventionEnumType : NetFrameworkWin32.IType_Ptr := NetFrameworkBase.System.Reflection.CallingConventions.Instance;
      p_callConventionEnum : aliased VARIANT := To_Variant (CreateEnum (p_callConventionEnumType, callConvention'Enum_rep));
      p4_Parameters : aliased LPSAFEARRAY := null;
      p4_Bounds     : aliased SAFEARRAYBOUND := (types'Length , 0);
      p4_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p4_Tmp        : aliased IUnknown_Ptr;
      p4_Tmp_Ptr    : access IUnknown_Ptr := p4_Tmp'access;
      p5_Parameters : aliased LPSAFEARRAY := null;
      p5_Bounds     : aliased SAFEARRAYBOUND := (modifiers'Length , 0);
      p5_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p5_Tmp        : aliased IUnknown_Ptr;
      p5_Tmp_Ptr    : access IUnknown_Ptr := p5_Tmp'access;
      RetVal        : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.MethodInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(name);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      p_Value := p_bindingAttrEnum;
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 2;
      p_Value := GetObject (binder.m_Kind);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 3;
      p_Value := p_callConventionEnum;
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 4;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p4_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p4_Bounds'access);
         for i in types'range loop
            p4_Index(1) := Interfaces.C.long(i) - 1;
            p4_Tmp := GetObject (types(i).m_Kind);
            Hr := SafeArrayPutElement (p4_Parameters, p4_Index (p4_Index'first)'access, Convert (p4_Tmp));
         end loop;
         p_Value := To_Variant (p4_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 5;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p5_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p5_Bounds'access);
         for i in modifiers'range loop
            p5_Index(1) := Interfaces.C.long(i) - 1;
            p5_Tmp := GetObject (modifiers(i).m_Kind);
            Hr := SafeArrayPutElement (p5_Parameters, p5_Index (p5_Index'first)'access, Convert (p5_Tmp));
         end loop;
         p_Value := To_Variant (p5_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Reflection.ParameterModifier[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p4_Parameters);
      Hr := SafeArrayDestroy (p5_Parameters);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetMethod
   (
      this : in out Module.Kind;
      name : NetFrameworkBase.BSTR;
      types : NetFrameworkBase.System.Type_x.Kind_Array
   )
   return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (2 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetMethod");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      p1_Parameters : aliased LPSAFEARRAY := null;
      p1_Bounds     : aliased SAFEARRAYBOUND := (types'Length , 0);
      p1_Index      : aliased array(1..1) of aliased LONG := (others => 0);
      p1_Tmp        : aliased IUnknown_Ptr;
      p1_Tmp_Ptr    : access IUnknown_Ptr := p1_Tmp'access;
      RetVal        : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.MethodInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(name);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
      ------------------------------------------------------------
      p_Index(1) := 1;
      declare
         use Interfaces.C;
         function Convert is new Ada.Unchecked_Conversion (IUnknown_Ptr, LPVOID);
      begin
         p1_Parameters := SafeArrayCreate (VT_UNKNOWN'enum_rep, 1, p1_Bounds'access);
         for i in types'range loop
            p1_Index(1) := Interfaces.C.long(i) - 1;
            p1_Tmp := GetObject (types(i).m_Kind);
            Hr := SafeArrayPutElement (p1_Parameters, p1_Index (p1_Index'first)'access, Convert (p1_Tmp));
         end loop;
         p_Value := To_Variant (p1_Parameters, VT_UNKNOWN);
      end;
      -- fixme parameter type := [array] System.Type[]
   
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p1_Parameters);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetMethod
   (
      this : in out Module.Kind;
      name : NetFrameworkBase.BSTR
   )
   return NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr is
      function Convert is new Ada.Unchecked_Conversion (LPVARIANT,LPVOID);
      Hr            : HResult := 0;
      p_Parameters  : aliased LPSAFEARRAY := null;
      p_Bounds      : aliased SAFEARRAYBOUND := (1 , 0);
      p_Index       : aliased array(1..1) of aliased LONG := (others => 0);
      p_Value       : aliased VARIANT;
      p_Value_Ptr   : access VARIANT := p_Value'access;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetMethod");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Reflection.MethodInfo.Kind_Ptr := new NetFrameworkBase.System.Reflection.MethodInfo.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
      p_Parameters := SafeArrayCreate (VT_VARIANT'enum_rep, 1, p_Bounds'access);
      ------------------------------------------------------------
      p_Index(1) := 0;
      p_Value := To_Variant(name);
      Hr := SafeArrayPutElement (p_Parameters, p_Index(p_Index'first)'access, Convert (p_Value_Ptr));
   
      p_Target := GetObject(this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, p_Parameters, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      Hr := SafeArrayDestroy (p_Parameters);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ScopeName
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.BSTR is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ScopeName");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.BSTR;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function Name
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.BSTR is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("Name");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.BSTR;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SysFreeString (p_MethodName);
      RetVal := From_Variant (p_RetVal);
      return RetVal;
   end;
   
   function Assembly
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.Reflection.Assembly.Kind_Ptr is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("Assembly");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Reflection.Assembly.Kind_Ptr := new NetFrameworkBase.System.Reflection.Assembly.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function ModuleHandle
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.ModuleHandle.Kind_Ptr is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("ModuleHandle");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.ModuleHandle.Kind_Ptr := new NetFrameworkBase.System.ModuleHandle.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(GetProperty)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
   function GetSignerCertificate
   (
      this : in out Module.Kind
   )
   return NetFrameworkBase.System.Security.Cryptography.X509Certificates.X509Certificate.Kind_Ptr is
      Hr            : HResult := 0;
      p_Flags       : aliased NetFrameworkBase.UInt32 := 0;
      p_Target      : aliased VARIANT;
      p_MethodName  : BSTR := To_BSTR("GetSignerCertificate");
      p_RetVal      : aliased VARIANT;
      p_NetRetVal   : aliased IUnknown_Ptr := null;
      RetVal        : NetFrameworkBase.System.Security.Cryptography.X509Certificates.X509Certificate.Kind_Ptr := new NetFrameworkBase.System.Security.Cryptography.X509Certificates.X509Certificate.Kind;
   begin
      p_Flags := NetFrameworkWin32.BindingFlags'(Public)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(InvokeMethod)'Enum_rep;
      p_Flags := p_Flags or NetFrameworkWin32.BindingFlags'(Instance)'Enum_rep;
   
      p_Target := GetObject (this.m_kind);
      p_RetVal := InvokeMethod (Instance, p_Target, p_MethodName, p_Flags, null, p_NetRetVal);
   
      SetObject (RetVal.m_Kind, p_RetVal);
      SetObject (RetVal.m_Kind, p_NetRetVal);
      SysFreeString (p_MethodName);
      return RetVal;
   end;
   
end;
